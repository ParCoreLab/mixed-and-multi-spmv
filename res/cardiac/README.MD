This directory contains sparse matrices and right-hand side vectors
from cardiac electrophysiology simulations. More specifically, these
linear systems come from an anisotropic diffusion equation that arises
from an operator splitting strategy for solving the monodomain
equations. The data is generated by the Lynx cardiac electrophysiology
simulation code and is based on unstructured computational meshes from
a dataset concerning acute myocardial ischemia in humans.

The data is provided as gzip-compressed files in Matrix Market (.mtx)
format, a commonly used ASCII format for storing and exchanging sparse
matrices.

The following table gives an overview of the matrices.

    mesh   	conductivity	time/space discretisation   	time step [µs]	rows/columns 	nonzeros

---

heart01 uniform backward Euler/finite volume 100 4 717 53 633
heart01 transv. iso backward Euler/finite volume 100 4 717 53 633
heart02 uniform backward Euler/finite volume 100 210 101 2 937 795
heart02 transv. iso backward Euler/finite volume 100 210 101 2 937 795
heart03 uniform backward Euler/finite volume 100 1 607 708 23 597 002
heart03 transv. iso backward Euler/finite volume 100 1 607 708 23 597 002
heart04 uniform backward Euler/finite volume 100 3 031 704 44 986 514
heart04 transv. iso backward Euler/finite volume 100 3 031 704 44 986 514
heart05 uniform backward Euler/finite volume 100 7 205 076 107 994 304
heart06 uniform backward Euler/finite volume 100 23 595 379 357 427 713
heart07 uniform backward Euler/finite volume 100 55 603 164 846 710 472

---

If you have any questions, please reach out to James D. Trotter
<james@simula.no>.

## Background

The original dataset was made available by Martinez-Navarro,
Rodriguez, Bueno-Orovio and Minchole (2019). Based on this dataset,
Julie Johanne Uv (julie@simula.no) provided a biventricular surface
file, and Gmsh was used to create a set of tetrahedral meshes. The
meshes range in size from about 5000 up to about 55 million
tetrahedra. Finally, the Laplace-Dirichlet Rule Based method was used
to generate myocardial fibre orientations (Bayer et al., 2012).

The Lynx cardiac electrophysiology simulator is based on solving the
monodomain equations and uses the ten Tusscher and Panfilov (2006)
model of human cardiac muscle cells.

The numerical strategy used to solve the monodomain equations is based
on an operator splitting technique, leading to a two-part solution
procedure during each time step:

- The ODE part solves a system of non-linear ordinary differential
  equations derived from a model of ionic currents in the cardiac
  cells.

- The PDE part solves a linear, parabolic partial differential
  equation representing the anisotropic diffusion of electric
  potential in the cardiac tissue.

The sparse matrices and right-hand side vectors provided here arise
from solving the anisotropic diffusion equation. Different strategies
may be used, including an explicit, forward Euler and an implicit,
backward Euler time stepping scheme. Discretisation in space is based
on a cell-centered finite volume method.

The sparsity pattern and nonzero entries of the provided matrices
depend on the cardiac mesh, the conductivity tensor and the chosen
time stepping scheme and time step. Here, we have used a backward
Euler scheme with a time step of 100 microseconds. For the
conductivity, the simplest case is to simply use a constant. More
advanced cases use fibre orientations of the cardiac muscle cells to
define transverselly isotropic or fully anisotropic conductivity
tensors.

The rows and columns of the sparse matrices have also been reordered
to improve performance by using the METIS graph partitioner.

The right-hand sides are obtained from an apical pacing benchmark,
where a stimulus is applied to the apex of the right ventricle. (For
the particular mesh that is used, the apex is located at the point
(345.54, 1232.91, 170.73), and the stimulus is applied for 1 ms in a
ball-shaped region with a radius of 5 mm.)

## References

Martinez-Navarro, Hector and Rodriguez, Blanca and Bueno-Orovio,
Alfonso and Minchole, Ana. (2019). “Repository for modelling acute
myocardial ischemia: simulation scripts and torso-heart mesh.”
University of Oxford.
https://ora.ox.ac.uk/objects/uuid:951b086c-c4ba-41ef-b967-c2106d87ee06

Bayer, J.D., Blake, R.C., Plank, G. and Trayanova, N.A. (2012).
“A novel rule-based algorithm for assigning myocardial fiber
orientation to computational heart models.” Annals of biomedical
engineering, 40(10), pp.2243-2254.
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3518842/

C. Geuzaine and J.-F. Remacle. “Gmsh: a three-dimensional finite
element mesh generator with built-in pre- and post-processing
facilities.” International Journal for Numerical Methods in
Engineering 79(11), pp. 1309-1331, 2009.

K.H.W.J. ten Tusscher and A.V. Panfilov. (2006). “Alternans and
spiral breakup in a human ventricular tissue model.” Am J Physiol
Heart Circ Physiol. 2006; 291(3): H1088-100. doi:
10.1152/ajpheart.00109.2006.

---

James D. Trotter,
Postdoctoral Fellow,
Department of High-Performance Computing,
Simula Research Laboratory, Norway

December 15, 2021

---

Extra by email from Xing Cai:
As mentioned during our previous meeting, a sparse matrix takes part in a cardiac simulator through a SpMV at each time step.
In the simplest form, the output vector of the SpMV from the previous time step becomes the input vector to the SpMV for the next time.

---

Extra by email from James D. Trotter:
Hi,

Happy new year to you too, Erhan.

Your interpretation of how to perform the cardiac simulation is mostly correct. However, there are essentially two different modes that the cardiac simulator can operate in: an explicit and an implicit method. Please note that the matrices I have shared with you so far are based on using the implicit scheme. If you would like, I can also prepare matrices for the explicit scheme, which, perhaps, is more relevant for your use case. (The matrices will anyway have exactly the same nonzero patterns, but the values will be different.)

The explicit method works as you describe, where every time step consists of a single SpMV followed by swapping the two vectors.

The implicit method is a little more complicated. So, at the i-th time step, instead of SpMV, one needs to solve the linear system ‘Ax*{i+1}=x*{i}’ for ‘x*{i+1}’. After solving the linear system, the two vectors are swapped, (that is, ’x*{i} <- x*{i+1}’ and ‘x*{i+1} <- x\_{i}’ simultaneously).

Now, there are many possible approaches to solving the linear system that appears with the implicit method. For example, a common choice is to use an iterative linear solver. One of the simplest examples of such a solver is the Jacobi method, but there are also more advanced techniques, such as the Conjugate Gradient algorithm. In any case, these methods are essentially based on repeatedly performing SpMV. (There are some more details involved, but I won’t go into detail here.)

Concerning your questions:

1. Generally speaking, the SpMV operation performed in the cardiac simulation is ‘y=Ax’.

2. In the folder containing the matrices that I shared with you earlier, you will also find several right-hand side vectors. Any of these can be used as realistic initial conditions. Note that only one vector is really needed to start the simulation. The first vector is used with either the explicit or implicit method to compute the solution vector for the next time step. By swapping the vectors, the newly computed solution vector is used as the initial condition for the next time step.

3. Because each iteration advances the simulation in time, we often refer to these iterations as time steps. How many time steps to perform depends on how much of the cardiac activity that one would like to simulate. A basic simulation might simulate, say, one second of cardiac activity. If each time step corresponds to 0.1 milliseconds, then 10 000 time steps are needed.

4. The “transviso” matrices are treated in exactly the same way. The only difference is that these matrices give more realistic simulations, and they can make the simulation a bit more difficult by requiring much smaller time steps, and therefore more time steps will be needed in total.

Regarding the convergence and expected results of the simulation. I believe that if you perform enough time steps, you should see all the values of the solution vector converge towards the same number, which should be the average value of the initial vector.

I realise this is a lot of information, but I hope that I have answered your questions. Please let me know if you have any further questions or would like some more clarification.

Best wishes,
James

---

We probably want to use the forward mehtods. (explicit)

The matrices are in `/global/D1/homes/james/data/matrices/martinez-navarro-etal/`
